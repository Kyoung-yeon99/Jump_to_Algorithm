'''
인풋으로 주어지는 데이터는 내구도 데이터이며, 처음 주어진 컨베이어 벨트는 아무것도 없이 텅 비어있는 상태이다. 즉 시작시점에서 컨베이어 벨트에 올라가있는 로봇은 0개이다.
벨트가 각 칸 위에 있는 로봇과 함께 한 칸 이동한다. 1~n번까지의 컨베이어벨트는 오른쪽으로, n+1부터 2*n까지의 컨베이어벨트는 왼쪽으로 회전한다. 회전 하는 도중에 n번째 컨베이어벨트에 있는 로봇(회전하기 전에 n-1번째 컨베이어 벨트에 있던 로봇)은 내구도의 감소 없이 컨베이어벨트에서 삭제된다.
2*n번째 컨베이어벨트부터 시작하여 1번째 컨베이어 벨트까지 역순(컨베이어 벨트의 크기가 5라면, 10,9,8,7,6,5,4,3,2,1 순으로)으로 아래의 행동을 시행한다.
i번째 컨베이어벨트에 로봇이 있어야 한다.
i+1번째 컨베이어벨트에 로봇이 없어야 하며, i+1번째 컨베이어벨트의 내구도가 1 이상이어야 한다.
만약 a,b 조건을 모두 만족할 경우, i번째 로봇이 i+1번째 컨베이어벨트로 이동하며, i+1번째 컨베이어벨트의 내구도가 1만큼 감소한다.
혹시 이동하게 된 i+1번 컨베이어벨트가 n번째 컨베이어 벨트라면 로봇을 삭제한다. 삭제할때 추가적인 내구도의 감소가 이뤄지지 않는다. (이동할때만 감소하고, 삭제할땐 추가감소 없음)
1번째 컨베이어 벨트의 내구도가 1이 아니라면 로봇을 올리고 1번째 컨베이어벨트의 내구도를 1만큼 감소시킨다.
내구도가 0인 칸의 개수가 K개 이상이라면 과정을 종료하고 2~4번 과정이 수행된 횟수를 출력한다. 만약 내구도가 0인 칸의 개수가 K개 미만이라면 2번으로 돌아간다
'''

from collections import deque
N, K = map(int, input().split())
A = deque(list(map(int,input().split()))) #내구도
belt = deque([False for _ in range(N)]) #벨트 위 로봇 T/F
step = 0 #단계 수
while True:
    #내구도 0인 칸 수가 K개 이상이면 과정 종료
    if A.count(0) >= K:
        print(step)
        break
    #1. 벨트 & 로봇 회전
    A.rotate(1)
    belt.rotate(1) #맨앞, 뒤는 False ->자동으로 내리기
    belt[0], belt[-1] = False, False
    # print(f"회전: {A} {belt}")
    #2. 로봇 있으면 한칸 더 직진, 내구도 감소
    if any(belt):
        #맨 뒤 로봇(=가장 먼저 올라간 로봇)부터 이동
        for i in range(N-1,0,-1):
            #이동하려는 칸에 로봇이 없고, 해당 칸 내구도가 1 이상이면 이동
            if belt[i-1] is True and belt[i] == False and A[i]>=1:
                belt[i-1], belt[i] = belt[i], belt[i-1]
                A[i]-=1
    #언제든지 로봇이 내리는 위치에 도달하면 그 즉시 내린다.
    if belt[-1] == True:
        belt[-1] = False

    # print(f"이동: {A} {belt}")
    #3. 올리는 위치 칸 내구도가 0이 아니면 로봇 올리기
    if A[0]>0:
        belt[0]=True
        A[0]-=1
    #단계 + 1
    # print(f"로봇: {A} {belt}")
    step+=1

